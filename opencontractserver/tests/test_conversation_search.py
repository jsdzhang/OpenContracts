"""
Tests for conversation and message search functionality.

This test suite covers:
- Conversation vector search
- ChatMessage vector search
- Permission filtering
- GraphQL query integration
"""

import pytest
from django.contrib.auth import get_user_model
from django.core.files.base import ContentFile
from django.test import TestCase
from graphene.test import Client
from graphql_relay import to_global_id

from config.graphql.schema import schema
from opencontractserver.annotations.models import Embedding
from opencontractserver.conversations.models import ChatMessage, Conversation
from opencontractserver.corpuses.models import Corpus
from opencontractserver.documents.models import Document
from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
    CoreChatMessageVectorStore,
    CoreConversationVectorStore,
    VectorSearchQuery,
)
from opencontractserver.utils.permissioning import (
    PermissionTypes,
    set_permissions_for_obj_to_user,
)

User = get_user_model()


class TestContext:
    def __init__(self, user):
        self.user = user


class ConversationVectorSearchTest(TestCase):
    """Test conversation vector search functionality."""

    def setUp(self):
        """Set up test data."""
        # Create users
        self.user = User.objects.create_user(
            username="search_testuser", password="testpassword"
        )
        self.other_user = User.objects.create_user(
            username="other_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Search Test Corpus", creator=self.user
        )

        # Create document
        pdf_file = ContentFile(b"%PDF-1.4 test pdf content", name="test_search.pdf")
        self.doc = Document.objects.create(
            creator=self.user,
            title="Search Test Document",
            description="Test document for search",
            custom_meta={},
            pdf_file=pdf_file,
            backend_lock=True,
        )
        self.corpus.documents.add(self.doc)

        # Create conversations with different content
        self.conv1 = Conversation.objects.create(
            title="Machine Learning in Legal Analytics",
            description="Discussion about using ML for contract analysis",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv1,
            permissions=[PermissionTypes.ALL],
        )

        self.conv2 = Conversation.objects.create(
            title="Natural Language Processing Techniques",
            description="Exploring NLP methods for document understanding",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv2,
            permissions=[PermissionTypes.ALL],
        )

        self.conv3 = Conversation.objects.create(
            title="Agent-based Document Chat",
            description="Chat with document using AI agents",
            chat_with_document=self.doc,
            creator=self.user,
            conversation_type="chat",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv3,
            permissions=[PermissionTypes.ALL],
        )

        # Create a conversation owned by other_user
        self.other_conv = Conversation.objects.create(
            title="Private Discussion",
            description="This should not be visible to main user",
            chat_with_corpus=self.corpus,
            creator=self.other_user,
            conversation_type="thread",
            is_public=False,
        )

        # Create embeddings for conversations (using mock embeddings)
        # In real usage, these would be generated by an actual embedder
        self.create_mock_embedding(self.conv1, [0.1] * 384)
        self.create_mock_embedding(self.conv2, [0.2] * 384)
        self.create_mock_embedding(self.conv3, [0.3] * 384)
        self.create_mock_embedding(self.other_conv, [0.4] * 384)

    def create_mock_embedding(self, conversation, vector):
        """Create a mock embedding for a conversation."""
        Embedding.objects.create(
            conversation=conversation,
            embedder_path="test/embedder",
            vector_384=vector,
            creator=conversation.creator,
        )

    def test_conversation_has_embedding_mixin(self):
        """Test that Conversation model has HasEmbeddingMixin functionality."""
        # Test get_embedding_reference_kwargs
        kwargs = self.conv1.get_embedding_reference_kwargs()
        self.assertEqual(kwargs, {"conversation_id": self.conv1.pk})

        # Test add_embedding
        test_vector = [0.5] * 384
        embedding = self.conv1.add_embedding("test/new-embedder", test_vector)
        self.assertIsNotNone(embedding)
        self.assertEqual(embedding.conversation_id, self.conv1.pk)

        # Test get_embedding
        retrieved_vector = self.conv1.get_embedding("test/new-embedder", 384)
        self.assertEqual(len(retrieved_vector), 384)

    def test_conversation_queryset_vector_search(self):
        """Test ConversationQuerySet vector search capabilities."""
        # Create a query vector
        query_vector = [0.15] * 384  # Should be close to conv1's [0.1]*384

        # Perform search
        results = Conversation.objects.search_by_embedding(
            query_vector=query_vector,
            embedder_path="test/embedder",
            top_k=2,
        )

        # Should return results
        self.assertGreater(len(results), 0)

        # Results should have similarity_score annotation
        for conv in results:
            self.assertTrue(hasattr(conv, "similarity_score"))
            self.assertIsNotNone(conv.similarity_score)

    def test_core_conversation_vector_store_permissions(self):
        """Test that CoreConversationVectorStore respects user permissions."""
        # Create vector store for main user with corpus filter
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        # Create search query
        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        # Perform search
        results = store.search(query)

        # Should only return conversations visible to user AND linked to corpus
        conversation_ids = {result.conversation.id for result in results}

        # Should include user's corpus-linked conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)

        # Should NOT include document-linked conversation (not part of corpus filter)
        self.assertNotIn(self.conv3.id, conversation_ids)

        # Should NOT include other user's private conversation
        self.assertNotIn(self.other_conv.id, conversation_ids)

        # Test without corpus filter to verify all user's conversations are visible
        store_no_filter = CoreConversationVectorStore(
            user_id=self.user.id,
            embedder_path="test/embedder",
        )

        results_all = store_no_filter.search(query)
        all_conversation_ids = {result.conversation.id for result in results_all}

        # Now all user's conversations should be included
        self.assertIn(self.conv1.id, all_conversation_ids)
        self.assertIn(self.conv2.id, all_conversation_ids)
        self.assertIn(self.conv3.id, all_conversation_ids)
        self.assertNotIn(self.other_conv.id, all_conversation_ids)

    def test_core_conversation_vector_store_corpus_filter(self):
        """Test filtering by corpus."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should include corpus conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)

    def test_core_conversation_vector_store_conversation_type_filter(self):
        """Test filtering by conversation type."""
        # Filter for threads only
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            conversation_type="thread",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should include thread conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)

        # Should NOT include chat conversations
        self.assertNotIn(self.conv3.id, conversation_ids)

    def test_soft_delete_exclusion(self):
        """Test that soft-deleted conversations are excluded."""
        # Soft delete a conversation
        from django.utils import timezone

        self.conv2.deleted_at = timezone.now()
        self.conv2.save()

        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should NOT include deleted conversation
        self.assertNotIn(self.conv2.id, conversation_ids)

    def test_search_with_query_text(self):
        """Test search using query_text (generates embedding)."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_text="test conversation search",
            similarity_top_k=10,
        )

        # Will fail without real embedder, but tests the code path
        try:
            results = store.search(query)
            self.assertIsInstance(results, list)
        except (ValueError, AttributeError, TypeError) as e:
            # Expected without real embedder service
            error_msg = str(e).lower()
            self.assertTrue(
                "len(" in error_msg or "embedder" in error_msg or "vector" in error_msg
            )

    def test_search_missing_query_raises_error(self):
        """Test that search raises ValueError when neither text nor embedding provided."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            similarity_top_k=10,
        )

        with self.assertRaises(ValueError) as ctx:
            store.search(query)

        self.assertIn("Either query_text or query_embedding", str(ctx.exception))


class MessageVectorSearchTest(TestCase):
    """Test message vector search functionality."""

    def setUp(self):
        """Set up test data."""
        # Create user
        self.user = User.objects.create_user(
            username="msg_search_user", password="testpassword"
        )
        self.other_user = User.objects.create_user(
            username="other_msg_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Message Search Corpus", creator=self.user
        )

        # Create conversation
        self.conversation = Conversation.objects.create(
            title="Test Thread",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation,
            permissions=[PermissionTypes.ALL],
        )

        # Create messages
        self.msg1 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="How do I analyze legal contracts using machine learning?",
        )

        self.msg2 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="LLM",
            content="You can use NLP techniques like named entity recognition and document classification.",
        )

        self.msg3 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="What about extracting specific clauses?",
        )

        # Create embeddings for messages
        self.create_mock_message_embedding(self.msg1, [0.1] * 384)
        self.create_mock_message_embedding(self.msg2, [0.2] * 384)
        self.create_mock_message_embedding(self.msg3, [0.3] * 384)

    def create_mock_message_embedding(self, message, vector):
        """Create a mock embedding for a message."""
        Embedding.objects.create(
            message=message,
            embedder_path="test/embedder",
            vector_384=vector,
            creator=message.creator,
        )

    def test_message_has_embedding_mixin(self):
        """Test that ChatMessage model has HasEmbeddingMixin functionality."""
        # Test get_embedding_reference_kwargs
        kwargs = self.msg1.get_embedding_reference_kwargs()
        self.assertEqual(kwargs, {"message_id": self.msg1.pk})

        # Test add_embedding
        test_vector = [0.5] * 384
        embedding = self.msg1.add_embedding("test/new-embedder", test_vector)
        self.assertIsNotNone(embedding)
        self.assertEqual(embedding.message_id, self.msg1.pk)

        # Test get_embedding
        retrieved_vector = self.msg1.get_embedding("test/new-embedder", 384)
        self.assertEqual(len(retrieved_vector), 384)

    def test_message_queryset_vector_search(self):
        """Test ChatMessageQuerySet vector search capabilities."""
        query_vector = [0.15] * 384

        results = ChatMessage.objects.search_by_embedding(
            query_vector=query_vector,
            embedder_path="test/embedder",
            top_k=2,
        )

        # Should return results
        self.assertGreater(len(results), 0)

        # Results should have similarity_score annotation
        for msg in results:
            self.assertTrue(hasattr(msg, "similarity_score"))
            self.assertIsNotNone(msg.similarity_score)

    def test_core_message_vector_store(self):
        """Test CoreChatMessageVectorStore functionality."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)

        # Should return messages
        self.assertGreater(len(results), 0)

        # Check that results are MessageSearchResult objects
        for result in results:
            self.assertIsNotNone(result.message)
            self.assertIsNotNone(result.similarity_score)

    def test_message_type_filter(self):
        """Test filtering by message type."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            msg_type="HUMAN",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        message_ids = {result.message.id for result in results}

        # Should include HUMAN messages
        self.assertIn(self.msg1.id, message_ids)
        self.assertIn(self.msg3.id, message_ids)

        # Should NOT include LLM messages
        self.assertNotIn(self.msg2.id, message_ids)

    def test_conversation_filter(self):
        """Test filtering by conversation."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            conversation_id=self.conversation.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)

        # All results should be from the specified conversation
        for result in results:
            self.assertEqual(result.message.conversation_id, self.conversation.id)

    def test_message_search_with_query_text(self):
        """Test message search using query_text (generates embedding)."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_text="test message search",
            similarity_top_k=10,
        )

        # Will fail without real embedder, but tests the code path
        try:
            results = store.search(query)
            self.assertIsInstance(results, list)
        except (ValueError, AttributeError, TypeError) as e:
            # Expected without real embedder service
            error_msg = str(e).lower()
            self.assertTrue(
                "len(" in error_msg or "embedder" in error_msg or "vector" in error_msg
            )

    def test_message_search_nonexistent_user(self):
        """Test message search with nonexistent user."""
        store = CoreChatMessageVectorStore(
            user_id=99999,  # Non-existent user
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)

        # Should return empty results, not crash
        self.assertEqual(len(results), 0)

    def test_message_search_missing_query_raises_error(self):
        """Test that message search raises ValueError when neither text nor embedding provided."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            similarity_top_k=10,
        )

        with self.assertRaises(ValueError) as ctx:
            store.search(query)

        self.assertIn("Either query_text or query_embedding", str(ctx.exception))


class GraphQLConversationSearchTest(TestCase):
    """Test GraphQL search queries."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="graphql_search_user", password="testpassword"
        )
        self.client = Client(schema, context_value=TestContext(self.user))

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="GraphQL Search Corpus", creator=self.user
        )

        # Create conversation
        self.conversation = Conversation.objects.create(
            title="GraphQL Test Conversation",
            description="Testing GraphQL search",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation,
            permissions=[PermissionTypes.ALL],
        )

        # Create message
        self.message = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="Test message content for search",
        )

        # Create embeddings
        Embedding.objects.create(
            conversation=self.conversation,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user,
        )

        Embedding.objects.create(
            message=self.message,
            embedder_path="test/embedder",
            vector_384=[0.2] * 384,
            creator=self.user,
        )

    def test_search_conversations_query(self):
        """Test the searchConversations GraphQL query."""
        query = """
            query SearchConversations($query: String!, $corpusId: ID, $topK: Int) {
                searchConversations(query: $query, corpusId: $corpusId, topK: $topK) {
                    id
                    title
                    description
                    conversationType
                }
            }
        """

        corpus_global_id = to_global_id("CorpusType", self.corpus.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test search query",
                "corpusId": corpus_global_id,
                "topK": 5,
            },
        )

        # In test environment, embedding generation from text may fail without real embedder service
        # This is expected - we're mainly testing that the GraphQL resolver structure is correct
        # The actual embedding search is tested in the vector store unit tests
        if result.get("errors"):
            # Verify it's an embedding-related error (not a permission or other critical error)
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len()" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error type: {error_message}",
            )
        else:
            # If embedder service is available, verify response structure
            self.assertIsNotNone(result.get("data"))
            conversations = result["data"]["searchConversations"]
            self.assertIsInstance(conversations, list)

    def test_search_messages_query(self):
        """Test the searchMessages GraphQL query."""
        query = """
            query SearchMessages($query: String!, $conversationId: ID, $topK: Int) {
                searchMessages(query: $query, conversationId: $conversationId, topK: $topK) {
                    id
                    content
                    msgType
                }
            }
        """

        conversation_global_id = to_global_id("ConversationType", self.conversation.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test message query",
                "conversationId": conversation_global_id,
                "topK": 5,
            },
        )

        # In test environment, embedding generation from text may fail without real embedder service
        # This is expected - we're mainly testing that the GraphQL resolver structure is correct
        # The actual embedding search is tested in the vector store unit tests
        if result.get("errors"):
            # Verify it's an embedding-related error (not a permission or other critical error)
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len()" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error type: {error_message}",
            )
        else:
            # If embedder service is available, verify response structure
            self.assertIsNotNone(result.get("data"))
            messages = result["data"]["searchMessages"]
            self.assertIsInstance(messages, list)

    def test_search_requires_authentication(self):
        """Test that search queries require authentication."""
        # Create client without authenticated user
        anonymous_client = Client(schema, context_value=TestContext(None))

        query = """
            query SearchConversations($query: String!) {
                searchConversations(query: $query) {
                    id
                    title
                }
            }
        """

        result = anonymous_client.execute(
            query,
            variables={"query": "test"},
        )

        # Should have errors (not authenticated)
        self.assertIsNotNone(result.get("errors"))

    def test_search_conversations_with_document_filter(self):
        """Test searchConversations with document_id filter."""
        pdf_file = ContentFile(b"%PDF-1.4 test pdf", name="doc_filter.pdf")
        doc = Document.objects.create(
            creator=self.user,
            title="Document Filter Test",
            pdf_file=pdf_file,
            backend_lock=True,
        )

        # Create document-linked conversation
        doc_conv = Conversation.objects.create(
            title="Document Conversation",
            chat_with_document=doc,
            creator=self.user,
            conversation_type="chat",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=doc_conv,
            permissions=[PermissionTypes.ALL],
        )

        Embedding.objects.create(
            conversation=doc_conv,
            embedder_path="test/embedder",
            vector_384=[0.3] * 384,
            creator=self.user,
        )

        query = """
            query SearchConversations($query: String!, $documentId: ID) {
                searchConversations(query: $query, documentId: $documentId) {
                    id
                    title
                }
            }
        """

        doc_global_id = to_global_id("DocumentType", doc.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test document query",
                "documentId": doc_global_id,
            },
        )

        # May fail without real embedder, but tests the resolver path
        if result.get("errors"):
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len(" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error: {error_message}",
            )

    def test_search_messages_with_corpus_filter(self):
        """Test searchMessages with corpus filter."""
        query = """
            query SearchMessages($query: String!, $corpusId: ID) {
                searchMessages(query: $query, corpusId: $corpusId) {
                    id
                    content
                }
            }
        """

        corpus_global_id = to_global_id("CorpusType", self.corpus.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test message query",
                "corpusId": corpus_global_id,
            },
        )

        # May fail without real embedder, but tests the resolver path
        if result.get("errors"):
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len(" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error: {error_message}",
            )

    def test_search_messages_with_msg_type_filter(self):
        """Test searchMessages with msg_type filter."""
        query = """
            query SearchMessages($query: String!, $conversationId: ID, $msgType: String) {
                searchMessages(
                    query: $query,
                    conversationId: $conversationId,
                    msgType: $msgType
                ) {
                    id
                    content
                    msgType
                }
            }
        """

        conversation_global_id = to_global_id("ConversationType", self.conversation.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test message",
                "conversationId": conversation_global_id,
                "msgType": "HUMAN",
            },
        )

        # May fail without real embedder
        if result.get("errors"):
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len(" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error: {error_message}",
            )

    def test_search_with_custom_top_k(self):
        """Test search queries with custom top_k parameter."""
        query = """
            query SearchConversations($query: String!, $corpusId: ID, $topK: Int) {
                searchConversations(query: $query, corpusId: $corpusId, topK: $topK) {
                    id
                    title
                }
            }
        """

        corpus_global_id = to_global_id("CorpusType", self.corpus.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test",
                "corpusId": corpus_global_id,
                "topK": 5,
            },
        )

        # May fail without real embedder
        if result.get("errors"):
            error_message = result["errors"][0]["message"]
            self.assertTrue(
                "len(" in error_message or "embedder" in error_message.lower(),
                f"Unexpected error: {error_message}",
            )


class ConversationPermissionTest(TestCase):
    """Test permission filtering in conversation search using visible_to_user() pattern."""

    def setUp(self):
        """Set up test users and conversations with various permission scenarios."""
        # Create users
        self.user1 = User.objects.create_user(username="user1", password="testpassword")
        self.user2 = User.objects.create_user(username="user2", password="testpassword")
        self.superuser = User.objects.create_superuser(
            username="superuser", password="testpassword", email="super@test.com"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Permission Test Corpus", creator=self.user1
        )

        # Create conversations with different visibility scenarios

        # 1. User1's private conversation (creator visibility)
        self.user1_private_conv = Conversation.objects.create(
            title="User1 Private Thread",
            description="Only visible to creator",
            chat_with_corpus=self.corpus,
            creator=self.user1,
            conversation_type="thread",
            is_public=False,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user1,
            instance=self.user1_private_conv,
            permissions=[PermissionTypes.ALL],
        )

        # 2. User1's public conversation (public visibility)
        self.user1_public_conv = Conversation.objects.create(
            title="User1 Public Thread",
            description="Visible to all users",
            chat_with_corpus=self.corpus,
            creator=self.user1,
            conversation_type="thread",
            is_public=True,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user1,
            instance=self.user1_public_conv,
            permissions=[PermissionTypes.ALL],
        )

        # 3. User1's private conversation shared with User2 (guardian permissions)
        self.shared_conv = Conversation.objects.create(
            title="Shared Thread",
            description="Shared explicitly via guardian permissions",
            chat_with_corpus=self.corpus,
            creator=self.user1,
            conversation_type="thread",
            is_public=False,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user1,
            instance=self.shared_conv,
            permissions=[PermissionTypes.ALL],
        )
        # Share with user2
        set_permissions_for_obj_to_user(
            user_val=self.user2,
            instance=self.shared_conv,
            permissions=[PermissionTypes.READ],
        )

        # 4. User2's completely private conversation (not accessible to user1)
        self.user2_private_conv = Conversation.objects.create(
            title="User2 Private Thread",
            description="Not visible to user1",
            chat_with_corpus=self.corpus,
            creator=self.user2,
            conversation_type="thread",
            is_public=False,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user2,
            instance=self.user2_private_conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create embeddings for all conversations
        for conv in [
            self.user1_private_conv,
            self.user1_public_conv,
            self.shared_conv,
            self.user2_private_conv,
        ]:
            Embedding.objects.create(
                conversation=conv,
                embedder_path="test/embedder",
                vector_384=[0.1] * 384,
                creator=conv.creator,
            )

    def test_creator_sees_own_conversations(self):
        """Test that creator can see their own conversations."""
        store = CoreConversationVectorStore(
            user_id=self.user1.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # User1 should see all their own conversations
        self.assertIn(self.user1_private_conv.id, conversation_ids)
        self.assertIn(self.user1_public_conv.id, conversation_ids)
        self.assertIn(self.shared_conv.id, conversation_ids)

        # User1 should NOT see user2's private conversation
        self.assertNotIn(self.user2_private_conv.id, conversation_ids)

    def test_guardian_permission_sharing(self):
        """Test that explicitly shared conversations appear in search."""
        store = CoreConversationVectorStore(
            user_id=self.user2.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # User2 should see shared conversation (via guardian permissions)
        self.assertIn(self.shared_conv.id, conversation_ids)

        # User2 should see public conversation
        self.assertIn(self.user1_public_conv.id, conversation_ids)

        # User2 should see their own private conversation
        self.assertIn(self.user2_private_conv.id, conversation_ids)

        # User2 should NOT see user1's other private conversation
        self.assertNotIn(self.user1_private_conv.id, conversation_ids)

    def test_public_conversations_visible_to_all(self):
        """Test that public conversations are visible to all authenticated users."""
        # User2 should see user1's public conversation
        store = CoreConversationVectorStore(
            user_id=self.user2.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should see public conversation
        self.assertIn(self.user1_public_conv.id, conversation_ids)

    def test_permission_revocation(self):
        """Test that revoking permissions excludes conversations from search."""
        from guardian.shortcuts import remove_perm

        # Initially, user2 should see shared conversation
        store = CoreConversationVectorStore(
            user_id=self.user2.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}
        self.assertIn(self.shared_conv.id, conversation_ids)

        # Revoke permission
        remove_perm("read_conversation", self.user2, self.shared_conv)

        # Now user2 should NOT see shared conversation
        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}
        self.assertNotIn(self.shared_conv.id, conversation_ids)

    def test_superuser_sees_everything(self):
        """Test that superusers can see all conversations."""
        store = CoreConversationVectorStore(
            user_id=self.superuser.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Superuser should see ALL conversations
        self.assertIn(self.user1_private_conv.id, conversation_ids)
        self.assertIn(self.user1_public_conv.id, conversation_ids)
        self.assertIn(self.shared_conv.id, conversation_ids)
        self.assertIn(self.user2_private_conv.id, conversation_ids)

    def test_anonymous_user_public_only(self):
        """Test that anonymous users only see public conversations."""
        # Anonymous user (no user_id)
        store = CoreConversationVectorStore(
            user_id=None,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Anonymous should ONLY see public conversations
        self.assertIn(self.user1_public_conv.id, conversation_ids)

        # Anonymous should NOT see private or shared conversations
        self.assertNotIn(self.user1_private_conv.id, conversation_ids)
        self.assertNotIn(self.shared_conv.id, conversation_ids)
        self.assertNotIn(self.user2_private_conv.id, conversation_ids)

    def test_soft_deleted_conversations_excluded(self):
        """Test that soft-deleted conversations are excluded from search."""
        from django.utils import timezone

        # Soft delete a conversation
        self.user1_private_conv.deleted_at = timezone.now()
        self.user1_private_conv.save()

        store = CoreConversationVectorStore(
            user_id=self.user1.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should NOT include soft-deleted conversation
        self.assertNotIn(self.user1_private_conv.id, conversation_ids)


class MessagePermissionTest(TestCase):
    """Test that message search inherits conversation visibility."""

    def setUp(self):
        """Set up test data."""
        # Create users
        self.user1 = User.objects.create_user(
            username="msg_user1", password="testpassword"
        )
        self.user2 = User.objects.create_user(
            username="msg_user2", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Message Permission Corpus", creator=self.user1
        )

        # Create user1's private conversation
        self.user1_private_conv = Conversation.objects.create(
            title="User1 Private Chat",
            chat_with_corpus=self.corpus,
            creator=self.user1,
            conversation_type="thread",
            is_public=False,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user1,
            instance=self.user1_private_conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create user1's public conversation
        self.user1_public_conv = Conversation.objects.create(
            title="User1 Public Chat",
            chat_with_corpus=self.corpus,
            creator=self.user1,
            conversation_type="thread",
            is_public=True,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user1,
            instance=self.user1_public_conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create messages in private conversation
        self.private_msg1 = ChatMessage.objects.create(
            conversation=self.user1_private_conv,
            creator=self.user1,
            msg_type="HUMAN",
            content="Private message 1",
        )

        # Create messages in public conversation
        self.public_msg1 = ChatMessage.objects.create(
            conversation=self.user1_public_conv,
            creator=self.user1,
            msg_type="HUMAN",
            content="Public message 1",
        )

        # Create embeddings
        Embedding.objects.create(
            message=self.private_msg1,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user1,
        )
        Embedding.objects.create(
            message=self.public_msg1,
            embedder_path="test/embedder",
            vector_384=[0.2] * 384,
            creator=self.user1,
        )

    def test_message_search_inherits_conversation_visibility(self):
        """Test that messages are only visible if their conversation is visible."""
        # User2 searching for messages
        store = CoreChatMessageVectorStore(
            user_id=self.user2.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        message_ids = {result.message.id for result in results}

        # User2 should see messages from public conversation
        self.assertIn(self.public_msg1.id, message_ids)

        # User2 should NOT see messages from private conversation
        self.assertNotIn(self.private_msg1.id, message_ids)

    def test_creator_sees_own_messages(self):
        """Test that creator can see messages in their own conversations."""
        store = CoreChatMessageVectorStore(
            user_id=self.user1.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        message_ids = {result.message.id for result in results}

        # User1 should see messages from both conversations
        self.assertIn(self.private_msg1.id, message_ids)
        self.assertIn(self.public_msg1.id, message_ids)


@pytest.mark.django_db
class AsyncConversationSearchTest(TestCase):
    """Test async search methods in CoreConversationVectorStore."""

    def setUp(self):
        """Set up test data."""
        # Create user
        self.user = User.objects.create_user(
            username="async_conv_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Async Conversation Test Corpus", creator=self.user
        )

        # Create conversations
        self.conversation1 = Conversation.objects.create(
            title="Async Test Conversation 1",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation1,
            permissions=[PermissionTypes.ALL],
        )

        self.conversation2 = Conversation.objects.create(
            title="Async Test Conversation 2",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation2,
            permissions=[PermissionTypes.ALL],
        )

        # Create embeddings
        Embedding.objects.create(
            conversation=self.conversation1,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user,
        )

        Embedding.objects.create(
            conversation=self.conversation2,
            embedder_path="test/embedder",
            vector_384=[0.2] * 384,
            creator=self.user,
        )

    @pytest.mark.asyncio
    async def test_async_conversation_search(self):
        """Test CoreConversationVectorStore.async_search method."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should return results
        self.assertGreater(len(results), 0)

        # Verify conversation IDs
        conversation_ids = {r.conversation.id for r in results}
        self.assertIn(self.conversation1.id, conversation_ids)
        self.assertIn(self.conversation2.id, conversation_ids)

        # Verify similarity scores are present
        for result in results:
            self.assertIsNotNone(result.similarity_score)
            self.assertIsInstance(result.similarity_score, float)

    @pytest.mark.asyncio
    async def test_async_conversation_search_with_filters(self):
        """Test async search with additional filters."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            conversation_type="thread",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should work with type filter
        self.assertIsInstance(results, list)

    @pytest.mark.asyncio
    async def test_async_conversation_search_nonexistent_user(self):
        """Test async search gracefully handles nonexistent user."""
        store = CoreConversationVectorStore(
            user_id=99999,  # Non-existent user
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should return empty results, not crash
        self.assertEqual(len(results), 0)

    @pytest.mark.asyncio
    async def test_async_conversation_search_with_top_k(self):
        """Test async search respects top_k parameter."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=1,  # Limit to 1 result
        )

        results = await store.async_search(query)

        # Should respect top_k limit
        self.assertLessEqual(len(results), 1)

    @pytest.mark.asyncio
    async def test_async_search_with_query_text(self):
        """Test async search using query_text (generates embedding)."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_text="async test conversation",
            similarity_top_k=10,
        )

        # Will fail without real embedder, but tests the code path
        try:
            results = await store.async_search(query)
            self.assertIsInstance(results, list)
        except (ValueError, AttributeError, TypeError) as e:
            # Expected without real embedder service
            error_msg = str(e).lower()
            self.assertTrue(
                "len(" in error_msg or "embedder" in error_msg or "vector" in error_msg
            )

    @pytest.mark.asyncio
    async def test_async_search_missing_query_raises_error(self):
        """Test that async search raises ValueError when neither text nor embedding provided."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            similarity_top_k=10,
        )

        with self.assertRaises(ValueError) as ctx:
            await store.async_search(query)

        self.assertIn("Either query_text or query_embedding", str(ctx.exception))


@pytest.mark.django_db
class AsyncMessageSearchTest(TestCase):
    """Test async search methods in CoreChatMessageVectorStore."""

    def setUp(self):
        """Set up test data."""
        # Create user
        self.user = User.objects.create_user(
            username="async_msg_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Async Message Test Corpus", creator=self.user
        )

        # Create conversation
        self.conversation = Conversation.objects.create(
            title="Async Message Test Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation,
            permissions=[PermissionTypes.ALL],
        )

        # Create messages
        self.message1 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="First async test message",
        )

        self.message2 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="LLM",
            content="Second async test message",
        )

        # Create embeddings
        Embedding.objects.create(
            message=self.message1,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user,
        )

        Embedding.objects.create(
            message=self.message2,
            embedder_path="test/embedder",
            vector_384=[0.2] * 384,
            creator=self.user,
        )

    @pytest.mark.asyncio
    async def test_async_message_search(self):
        """Test CoreChatMessageVectorStore.async_search method."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should return results
        self.assertGreater(len(results), 0)

        # Verify message IDs
        message_ids = {r.message.id for r in results}
        self.assertIn(self.message1.id, message_ids)
        self.assertIn(self.message2.id, message_ids)

        # Verify similarity scores
        for result in results:
            self.assertIsNotNone(result.similarity_score)
            self.assertIsInstance(result.similarity_score, float)

    @pytest.mark.asyncio
    async def test_async_message_search_with_msg_type_filter(self):
        """Test async message search with message type filter."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            msg_type="HUMAN",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should only return HUMAN messages
        for result in results:
            self.assertEqual(result.message.msg_type, "HUMAN")

    @pytest.mark.asyncio
    async def test_async_message_search_with_conversation_filter(self):
        """Test async message search with conversation filter."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            conversation_id=self.conversation.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # All results should be from the specified conversation
        for result in results:
            self.assertEqual(result.message.conversation_id, self.conversation.id)

    @pytest.mark.asyncio
    async def test_async_message_search_nonexistent_user(self):
        """Test async message search with nonexistent user."""
        store = CoreChatMessageVectorStore(
            user_id=99999,  # Non-existent user
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = await store.async_search(query)

        # Should return empty results, not crash
        self.assertEqual(len(results), 0)

    @pytest.mark.asyncio
    async def test_async_message_search_with_query_text(self):
        """Test async message search using query_text (generates embedding)."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_text="async test message",
            similarity_top_k=10,
        )

        # Will fail without real embedder, but tests the code path
        try:
            results = await store.async_search(query)
            self.assertIsInstance(results, list)
        except (ValueError, AttributeError, TypeError) as e:
            # Expected without real embedder service
            error_msg = str(e).lower()
            self.assertTrue(
                "len(" in error_msg or "embedder" in error_msg or "vector" in error_msg
            )

    @pytest.mark.asyncio
    async def test_async_message_search_missing_query_raises_error(self):
        """Test that async message search raises ValueError when query missing."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            similarity_top_k=10,
        )

        with self.assertRaises(ValueError) as ctx:
            await store.async_search(query)

        self.assertIn("Either query_text or query_embedding", str(ctx.exception))


class VectorStoreEdgeCasesTest(TestCase):
    """Test edge cases and error paths in vector stores."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="edge_case_user", password="testpassword"
        )
        self.corpus = Corpus.objects.create(title="Edge Case Corpus", creator=self.user)

    def test_conversation_store_requires_corpus_or_embedder(self):
        """Test that CoreConversationVectorStore requires either corpus_id or embedder_path."""
        with self.assertRaises(ValueError) as ctx:
            CoreConversationVectorStore(
                user_id=self.user.id,
                # No corpus_id or embedder_path provided
            )

        self.assertIn("requires either 'corpus_id'", str(ctx.exception))

    def test_message_store_requires_corpus_or_embedder(self):
        """Test that CoreChatMessageVectorStore requires either corpus_id or embedder_path."""
        with self.assertRaises(ValueError) as ctx:
            CoreChatMessageVectorStore(
                user_id=self.user.id,
                # No corpus_id or embedder_path provided
            )

        self.assertIn("requires either 'corpus_id'", str(ctx.exception))

    def test_conversation_store_with_invalid_embed_dim(self):
        """Test conversation store handles invalid embed dimensions gracefully."""
        # Create store with invalid dimension (not 384, 768, 1536, or 3072)
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
            embed_dim=512,  # Invalid dimension
        )

        # Should fall back to default dimension (384)
        self.assertEqual(store.embed_dim, 384)

    def test_message_store_with_invalid_embed_dim(self):
        """Test message store handles invalid embed dimensions gracefully."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
            embed_dim=999,  # Invalid dimension
        )

        # Should fall back to default dimension (384)
        self.assertEqual(store.embed_dim, 384)

    def test_conversation_store_with_document_id_filter(self):
        """Test conversation store filtering by document_id."""
        pdf_file = ContentFile(b"%PDF-1.4 test", name="doc_test.pdf")
        doc = Document.objects.create(
            creator=self.user,
            title="Test Document",
            pdf_file=pdf_file,
            backend_lock=True,
        )

        # Create document-linked conversation
        conv = Conversation.objects.create(
            title="Document Conversation",
            chat_with_document=doc,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conv,
            permissions=[PermissionTypes.ALL],
        )

        Embedding.objects.create(
            conversation=conv,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user,
        )

        # Create store with document_id filter
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            document_id=doc.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should include document-linked conversation
        self.assertIn(conv.id, conversation_ids)

    def test_message_store_exclude_deleted_parameter(self):
        """Test message store exclude_deleted parameter exists and can be set."""
        # Test that exclude_deleted parameter can be set to False
        store_include = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
            exclude_deleted=False,
        )

        # Verify the parameter is set correctly
        self.assertEqual(store_include.exclude_deleted, False)

        # Test default value (True)
        store_default = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        self.assertEqual(store_default.exclude_deleted, True)


class ConversationModelVisibilityTest(TestCase):
    """Test SoftDeleteQuerySet.visible_to_user edge cases."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="visibility_user", password="testpassword"
        )
        self.corpus = Corpus.objects.create(
            title="Visibility Test Corpus", creator=self.user
        )

    def test_visible_to_user_with_none_user(self):
        """Test visible_to_user handles None user (anonymous)."""
        # Create public conversation
        public_conv = Conversation.objects.create(
            title="Public Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=True,
        )

        # Create private conversation
        private_conv = Conversation.objects.create(
            title="Private Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=False,
        )

        # Query with None user (anonymous)
        visible = Conversation.objects.visible_to_user(None)

        visible_ids = set(visible.values_list("id", flat=True))

        # Anonymous should only see public
        self.assertIn(public_conv.id, visible_ids)
        self.assertNotIn(private_conv.id, visible_ids)

    def test_visible_to_user_fallback_no_permission_model(self):
        """Test visible_to_user fallback when permission model doesn't exist."""
        # This tests the LookupError exception handling in visible_to_user
        # The code handles cases where guardian permission models don't exist

        # Create conversation
        conv = Conversation.objects.create(
            title="Test Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=False,
        )

        # Query as creator
        visible = Conversation.objects.visible_to_user(self.user)
        visible_ids = set(visible.values_list("id", flat=True))

        # Creator should see their own conversation
        self.assertIn(conv.id, visible_ids)

    def test_visible_to_user_superuser_sees_all(self):
        """Test that superusers see all conversations including private ones."""
        # Create a superuser
        superuser = User.objects.create_superuser(
            username="admin", password="admin", email="admin@test.com"
        )

        # Create private conversation owned by regular user
        private_conv = Conversation.objects.create(
            title="Private Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=False,
        )

        # Create public conversation
        public_conv = Conversation.objects.create(
            title="Public Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=True,
        )

        # Superuser should see both
        visible = Conversation.objects.visible_to_user(superuser)
        visible_ids = set(visible.values_list("id", flat=True))

        self.assertIn(private_conv.id, visible_ids)
        self.assertIn(public_conv.id, visible_ids)

    def test_visible_to_user_with_shared_permissions(self):
        """Test that users see conversations explicitly shared with them."""
        # Create second user
        other_user = User.objects.create_user(
            username="other_user", password="testpass"
        )

        # Create private conversation owned by first user
        conv = Conversation.objects.create(
            title="Shared Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=False,
        )

        # Share with other_user
        set_permissions_for_obj_to_user(
            user_val=other_user,
            instance=conv,
            permissions=[PermissionTypes.READ],
        )

        # other_user should be able to see it
        visible = Conversation.objects.visible_to_user(other_user)
        visible_ids = set(visible.values_list("id", flat=True))

        self.assertIn(conv.id, visible_ids)

        # But they shouldn't see conversations they don't have access to
        private_conv = Conversation.objects.create(
            title="Not Shared",
            chat_with_corpus=self.corpus,
            creator=self.user,
            is_public=False,
        )

        visible2 = Conversation.objects.visible_to_user(other_user)
        visible_ids2 = set(visible2.values_list("id", flat=True))

        self.assertIn(conv.id, visible_ids2)  # Still sees shared one
        self.assertNotIn(private_conv.id, visible_ids2)  # Doesn't see unshared


class EmbeddingDimensionTest(TestCase):
    """Test vector search with different embedding dimensions."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="dimension_user", password="testpassword"
        )
        self.corpus = Corpus.objects.create(
            title="Dimension Test Corpus", creator=self.user
        )

    def test_conversation_search_with_768_dimension(self):
        """Test conversation search with 768-dimensional embeddings."""
        conv = Conversation.objects.create(
            title="768D Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create 768-dimensional embedding
        Embedding.objects.create(
            conversation=conv,
            embedder_path="test/embedder-768",
            vector_768=[0.1] * 768,
            creator=self.user,
        )

        # Search with 768-dimensional vector
        results = Conversation.objects.search_by_embedding(
            query_vector=[0.1] * 768,
            embedder_path="test/embedder-768",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        conv_ids = [c.id for c in results]
        self.assertIn(conv.id, conv_ids)

    def test_conversation_search_with_1536_dimension(self):
        """Test conversation search with 1536-dimensional embeddings."""
        conv = Conversation.objects.create(
            title="1536D Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create 1536-dimensional embedding
        Embedding.objects.create(
            conversation=conv,
            embedder_path="test/embedder-1536",
            vector_1536=[0.1] * 1536,
            creator=self.user,
        )

        # Search with 1536-dimensional vector
        results = Conversation.objects.search_by_embedding(
            query_vector=[0.1] * 1536,
            embedder_path="test/embedder-1536",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        conv_ids = [c.id for c in results]
        self.assertIn(conv.id, conv_ids)

    def test_conversation_search_with_3072_dimension(self):
        """Test conversation search with 3072-dimensional embeddings."""
        conv = Conversation.objects.create(
            title="3072D Conversation",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conv,
            permissions=[PermissionTypes.ALL],
        )

        # Create 3072-dimensional embedding
        Embedding.objects.create(
            conversation=conv,
            embedder_path="test/embedder-3072",
            vector_3072=[0.1] * 3072,
            creator=self.user,
        )

        # Search with 3072-dimensional vector
        results = Conversation.objects.search_by_embedding(
            query_vector=[0.1] * 3072,
            embedder_path="test/embedder-3072",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        conv_ids = [c.id for c in results]
        self.assertIn(conv.id, conv_ids)

    def test_message_search_with_768_dimension(self):
        """Test message search with 768-dimensional embeddings."""
        conversation = Conversation.objects.create(
            title="768D Message Test",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conversation,
            permissions=[PermissionTypes.ALL],
        )

        message = ChatMessage.objects.create(
            conversation=conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="Test message 768D",
        )

        # Create 768-dimensional embedding
        Embedding.objects.create(
            message=message,
            embedder_path="test/embedder-768",
            vector_768=[0.1] * 768,
            creator=self.user,
        )

        # Search with 768-dimensional vector
        results = ChatMessage.objects.search_by_embedding(
            query_vector=[0.1] * 768,
            embedder_path="test/embedder-768",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        message_ids = [m.id for m in results]
        self.assertIn(message.id, message_ids)

    def test_message_search_with_1536_dimension(self):
        """Test message search with 1536-dimensional embeddings."""
        conversation = Conversation.objects.create(
            title="1536D Message Test",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conversation,
            permissions=[PermissionTypes.ALL],
        )

        message = ChatMessage.objects.create(
            conversation=conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="Test message 1536D",
        )

        # Create 1536-dimensional embedding
        Embedding.objects.create(
            message=message,
            embedder_path="test/embedder-1536",
            vector_1536=[0.1] * 1536,
            creator=self.user,
        )

        # Search with 1536-dimensional vector
        results = ChatMessage.objects.search_by_embedding(
            query_vector=[0.1] * 1536,
            embedder_path="test/embedder-1536",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        message_ids = [m.id for m in results]
        self.assertIn(message.id, message_ids)

    def test_message_search_with_3072_dimension(self):
        """Test message search with 3072-dimensional embeddings."""
        conversation = Conversation.objects.create(
            title="3072D Message Test",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=conversation,
            permissions=[PermissionTypes.ALL],
        )

        message = ChatMessage.objects.create(
            conversation=conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="Test message 3072D",
        )

        # Create 3072-dimensional embedding
        Embedding.objects.create(
            message=message,
            embedder_path="test/embedder-3072",
            vector_3072=[0.1] * 3072,
            creator=self.user,
        )

        # Search with 3072-dimensional vector
        results = ChatMessage.objects.search_by_embedding(
            query_vector=[0.1] * 3072,
            embedder_path="test/embedder-3072",
            top_k=10,
        )

        self.assertGreater(len(results), 0)
        message_ids = [m.id for m in results]
        self.assertIn(message.id, message_ids)

    def test_conversation_search_invalid_dimension_raises_error(self):
        """Test that invalid embedding dimensions raise ValueError."""
        with self.assertRaises(ValueError) as ctx:
            Conversation.objects.search_by_embedding(
                query_vector=[0.1] * 512,  # Invalid dimension
                embedder_path="test/embedder",
                top_k=10,
            )

        self.assertIn("Unsupported embedding dimension", str(ctx.exception))

    def test_message_search_invalid_dimension_raises_error(self):
        """Test that invalid message embedding dimensions raise ValueError."""
        with self.assertRaises(ValueError) as ctx:
            ChatMessage.objects.search_by_embedding(
                query_vector=[0.1] * 999,  # Invalid dimension
                embedder_path="test/embedder",
                top_k=10,
            )

        self.assertIn("Unsupported embedding dimension", str(ctx.exception))


class HelperFunctionsTest(TestCase):
    """Test utility helper functions in vector stores module."""

    def test_is_async_context_returns_false_in_sync(self):
        """Test _is_async_context returns False in synchronous context."""
        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _is_async_context,
        )

        # In sync context, should return False
        result = _is_async_context()
        self.assertFalse(result)

    def test_safe_queryset_info_sync_in_sync_context(self):
        """Test _safe_queryset_info_sync in synchronous context."""
        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _safe_queryset_info_sync,
        )

        # Create a simple queryset
        User.objects.create_user(username="helper_user", password="testpass")
        queryset = User.objects.filter(username="helper_user")

        # Should return count info
        result = _safe_queryset_info_sync(queryset, "Test query")
        self.assertIn("Test query:", result)
        self.assertIn("1 results", result)

    def test_safe_queryset_info_sync_handles_exception(self):
        """Test _safe_queryset_info_sync handles queryset exceptions."""
        from unittest.mock import Mock

        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _safe_queryset_info_sync,
        )

        # Create a mock queryset that raises an exception
        mock_qs = Mock()
        mock_qs.count.side_effect = Exception("Database error")

        result = _safe_queryset_info_sync(mock_qs, "Error test")
        self.assertIn("unable to count results", result)
        self.assertIn("Database error", result)

    @pytest.mark.asyncio
    async def test_is_async_context_returns_true_in_async(self):
        """Test _is_async_context returns True in asynchronous context."""
        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _is_async_context,
        )

        # In async context, should return True
        result = _is_async_context()
        self.assertTrue(result)

    @pytest.mark.asyncio
    async def test_safe_queryset_info_in_async_context(self):
        """Test _safe_queryset_info in asynchronous context."""
        from asgiref.sync import sync_to_async

        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _safe_queryset_info,
        )

        # Create queryset
        await sync_to_async(User.objects.create_user)(
            username="async_info_user", password="testpass"
        )
        queryset = User.objects.filter(username="async_info_user")

        # Should use async path (lines 33-35)
        result = await _safe_queryset_info(queryset, "Async test")
        self.assertIn("Async test:", result)
        self.assertIn("1 results", result)

    @pytest.mark.asyncio
    async def test_safe_queryset_info_handles_exception(self):
        """Test _safe_queryset_info handles exceptions gracefully."""
        from unittest.mock import Mock

        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _safe_queryset_info,
        )

        # Create mock queryset that raises exception
        mock_qs = Mock()
        mock_qs.count.side_effect = Exception("Async error")

        result = await _safe_queryset_info(mock_qs, "Error test")
        self.assertIn("unable to count results", result)
        self.assertIn("Async error", result)

    @pytest.mark.asyncio
    async def test_safe_execute_queryset_in_async_context(self):
        """Test _safe_execute_queryset in asynchronous context."""
        from asgiref.sync import sync_to_async

        from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
            _safe_execute_queryset,
        )

        # Create users
        await sync_to_async(User.objects.create_user)(
            username="async_exec1", password="testpass"
        )
        await sync_to_async(User.objects.create_user)(
            username="async_exec2", password="testpass"
        )
        queryset = User.objects.filter(username__startswith="async_exec")

        # Execute in async context (line 56)
        result = await _safe_execute_queryset(queryset)
        self.assertEqual(len(result), 2)
