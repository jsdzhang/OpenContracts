"""
Tests for conversation and message search functionality.

This test suite covers:
- Conversation vector search
- ChatMessage vector search
- Permission filtering
- GraphQL query integration
"""

from django.contrib.auth import get_user_model
from django.core.files.base import ContentFile
from django.test import TestCase
from graphene.test import Client
from graphql_relay import to_global_id

from config.graphql.schema import schema
from opencontractserver.annotations.models import Embedding
from opencontractserver.conversations.models import ChatMessage, Conversation
from opencontractserver.corpuses.models import Corpus
from opencontractserver.documents.models import Document
from opencontractserver.llms.vector_stores.core_conversation_vector_stores import (
    CoreChatMessageVectorStore,
    CoreConversationVectorStore,
    VectorSearchQuery,
)
from opencontractserver.utils.permissioning import (
    PermissionTypes,
    set_permissions_for_obj_to_user,
)

User = get_user_model()


class TestContext:
    def __init__(self, user):
        self.user = user


class ConversationVectorSearchTest(TestCase):
    """Test conversation vector search functionality."""

    def setUp(self):
        """Set up test data."""
        # Create users
        self.user = User.objects.create_user(
            username="search_testuser", password="testpassword"
        )
        self.other_user = User.objects.create_user(
            username="other_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Search Test Corpus", creator=self.user
        )

        # Create document
        pdf_file = ContentFile(b"%PDF-1.4 test pdf content", name="test_search.pdf")
        self.doc = Document.objects.create(
            creator=self.user,
            title="Search Test Document",
            description="Test document for search",
            custom_meta={},
            pdf_file=pdf_file,
            backend_lock=True,
        )
        self.corpus.documents.add(self.doc)

        # Create conversations with different content
        self.conv1 = Conversation.objects.create(
            title="Machine Learning in Legal Analytics",
            description="Discussion about using ML for contract analysis",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv1,
            permissions=[PermissionTypes.ALL],
        )

        self.conv2 = Conversation.objects.create(
            title="Natural Language Processing Techniques",
            description="Exploring NLP methods for document understanding",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv2,
            permissions=[PermissionTypes.ALL],
        )

        self.conv3 = Conversation.objects.create(
            title="Agent-based Document Chat",
            description="Chat with document using AI agents",
            chat_with_document=self.doc,
            creator=self.user,
            conversation_type="chat",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conv3,
            permissions=[PermissionTypes.ALL],
        )

        # Create a conversation owned by other_user
        self.other_conv = Conversation.objects.create(
            title="Private Discussion",
            description="This should not be visible to main user",
            chat_with_corpus=self.corpus,
            creator=self.other_user,
            conversation_type="thread",
            is_public=False,
        )

        # Create embeddings for conversations (using mock embeddings)
        # In real usage, these would be generated by an actual embedder
        self.create_mock_embedding(self.conv1, [0.1] * 384)
        self.create_mock_embedding(self.conv2, [0.2] * 384)
        self.create_mock_embedding(self.conv3, [0.3] * 384)
        self.create_mock_embedding(self.other_conv, [0.4] * 384)

    def create_mock_embedding(self, conversation, vector):
        """Create a mock embedding for a conversation."""
        Embedding.objects.create(
            conversation=conversation,
            embedder_path="test/embedder",
            vector_384=vector,
            creator=conversation.creator,
        )

    def test_conversation_has_embedding_mixin(self):
        """Test that Conversation model has HasEmbeddingMixin functionality."""
        # Test get_embedding_reference_kwargs
        kwargs = self.conv1.get_embedding_reference_kwargs()
        self.assertEqual(kwargs, {"conversation_id": self.conv1.pk})

        # Test add_embedding
        test_vector = [0.5] * 384
        embedding = self.conv1.add_embedding("test/new-embedder", test_vector)
        self.assertIsNotNone(embedding)
        self.assertEqual(embedding.conversation_id, self.conv1.pk)

        # Test get_embedding
        retrieved_vector = self.conv1.get_embedding("test/new-embedder", 384)
        self.assertEqual(len(retrieved_vector), 384)

    def test_conversation_queryset_vector_search(self):
        """Test ConversationQuerySet vector search capabilities."""
        # Create a query vector
        query_vector = [0.15] * 384  # Should be close to conv1's [0.1]*384

        # Perform search
        results = Conversation.objects.search_by_embedding(
            query_vector=query_vector,
            embedder_path="test/embedder",
            top_k=2,
        )

        # Should return results
        self.assertGreater(len(results), 0)

        # Results should have similarity_score annotation
        for conv in results:
            self.assertTrue(hasattr(conv, "similarity_score"))
            self.assertIsNotNone(conv.similarity_score)

    def test_core_conversation_vector_store_permissions(self):
        """Test that CoreConversationVectorStore respects user permissions."""
        # Create vector store for main user
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        # Create search query
        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        # Perform search
        results = store.search(query)

        # Should only return conversations visible to user
        conversation_ids = {result.conversation.id for result in results}

        # Should include user's conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)
        self.assertIn(self.conv3.id, conversation_ids)

        # Should NOT include other user's private conversation
        self.assertNotIn(self.other_conv.id, conversation_ids)

    def test_core_conversation_vector_store_corpus_filter(self):
        """Test filtering by corpus."""
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should include corpus conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)

    def test_core_conversation_vector_store_conversation_type_filter(self):
        """Test filtering by conversation type."""
        # Filter for threads only
        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            conversation_type="thread",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should include thread conversations
        self.assertIn(self.conv1.id, conversation_ids)
        self.assertIn(self.conv2.id, conversation_ids)

        # Should NOT include chat conversations
        self.assertNotIn(self.conv3.id, conversation_ids)

    def test_soft_delete_exclusion(self):
        """Test that soft-deleted conversations are excluded."""
        # Soft delete a conversation
        from django.utils import timezone

        self.conv2.deleted_at = timezone.now()
        self.conv2.save()

        store = CoreConversationVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        conversation_ids = {result.conversation.id for result in results}

        # Should NOT include deleted conversation
        self.assertNotIn(self.conv2.id, conversation_ids)


class MessageVectorSearchTest(TestCase):
    """Test message vector search functionality."""

    def setUp(self):
        """Set up test data."""
        # Create user
        self.user = User.objects.create_user(
            username="msg_search_user", password="testpassword"
        )
        self.other_user = User.objects.create_user(
            username="other_msg_user", password="testpassword"
        )

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="Message Search Corpus", creator=self.user
        )

        # Create conversation
        self.conversation = Conversation.objects.create(
            title="Test Thread",
            chat_with_corpus=self.corpus,
            creator=self.user,
            conversation_type="thread",
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation,
            permissions=[PermissionTypes.ALL],
        )

        # Create messages
        self.msg1 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="How do I analyze legal contracts using machine learning?",
        )

        self.msg2 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="LLM",
            content="You can use NLP techniques like named entity recognition and document classification.",
        )

        self.msg3 = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="What about extracting specific clauses?",
        )

        # Create embeddings for messages
        self.create_mock_message_embedding(self.msg1, [0.1] * 384)
        self.create_mock_message_embedding(self.msg2, [0.2] * 384)
        self.create_mock_message_embedding(self.msg3, [0.3] * 384)

    def create_mock_message_embedding(self, message, vector):
        """Create a mock embedding for a message."""
        Embedding.objects.create(
            message=message,
            embedder_path="test/embedder",
            vector_384=vector,
            creator=message.creator,
        )

    def test_message_has_embedding_mixin(self):
        """Test that ChatMessage model has HasEmbeddingMixin functionality."""
        # Test get_embedding_reference_kwargs
        kwargs = self.msg1.get_embedding_reference_kwargs()
        self.assertEqual(kwargs, {"message_id": self.msg1.pk})

        # Test add_embedding
        test_vector = [0.5] * 384
        embedding = self.msg1.add_embedding("test/new-embedder", test_vector)
        self.assertIsNotNone(embedding)
        self.assertEqual(embedding.message_id, self.msg1.pk)

        # Test get_embedding
        retrieved_vector = self.msg1.get_embedding("test/new-embedder", 384)
        self.assertEqual(len(retrieved_vector), 384)

    def test_message_queryset_vector_search(self):
        """Test ChatMessageQuerySet vector search capabilities."""
        query_vector = [0.15] * 384

        results = ChatMessage.objects.search_by_embedding(
            query_vector=query_vector,
            embedder_path="test/embedder",
            top_k=2,
        )

        # Should return results
        self.assertGreater(len(results), 0)

        # Results should have similarity_score annotation
        for msg in results:
            self.assertTrue(hasattr(msg, "similarity_score"))
            self.assertIsNotNone(msg.similarity_score)

    def test_core_message_vector_store(self):
        """Test CoreChatMessageVectorStore functionality."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)

        # Should return messages
        self.assertGreater(len(results), 0)

        # Check that results are MessageSearchResult objects
        for result in results:
            self.assertIsNotNone(result.message)
            self.assertIsNotNone(result.similarity_score)

    def test_message_type_filter(self):
        """Test filtering by message type."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            corpus_id=self.corpus.id,
            msg_type="HUMAN",
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)
        message_ids = {result.message.id for result in results}

        # Should include HUMAN messages
        self.assertIn(self.msg1.id, message_ids)
        self.assertIn(self.msg3.id, message_ids)

        # Should NOT include LLM messages
        self.assertNotIn(self.msg2.id, message_ids)

    def test_conversation_filter(self):
        """Test filtering by conversation."""
        store = CoreChatMessageVectorStore(
            user_id=self.user.id,
            conversation_id=self.conversation.id,
            embedder_path="test/embedder",
        )

        query = VectorSearchQuery(
            query_embedding=[0.1] * 384,
            similarity_top_k=10,
        )

        results = store.search(query)

        # All results should be from the specified conversation
        for result in results:
            self.assertEqual(result.message.conversation_id, self.conversation.id)


class GraphQLConversationSearchTest(TestCase):
    """Test GraphQL search queries."""

    def setUp(self):
        """Set up test data."""
        self.user = User.objects.create_user(
            username="graphql_search_user", password="testpassword"
        )
        self.client = Client(schema, context_value=TestContext(self.user))

        # Create corpus
        self.corpus = Corpus.objects.create(
            title="GraphQL Search Corpus", creator=self.user
        )

        # Create conversation
        self.conversation = Conversation.objects.create(
            title="GraphQL Test Conversation",
            description="Testing GraphQL search",
            chat_with_corpus=self.corpus,
            creator=self.user,
        )
        set_permissions_for_obj_to_user(
            user_val=self.user,
            instance=self.conversation,
            permissions=[PermissionTypes.ALL],
        )

        # Create message
        self.message = ChatMessage.objects.create(
            conversation=self.conversation,
            creator=self.user,
            msg_type="HUMAN",
            content="Test message content for search",
        )

        # Create embeddings
        Embedding.objects.create(
            conversation=self.conversation,
            embedder_path="test/embedder",
            vector_384=[0.1] * 384,
            creator=self.user,
        )

        Embedding.objects.create(
            message=self.message,
            embedder_path="test/embedder",
            vector_384=[0.2] * 384,
            creator=self.user,
        )

    def test_search_conversations_query(self):
        """Test the searchConversations GraphQL query."""
        query = """
            query SearchConversations($query: String!, $corpusId: ID, $topK: Int) {
                searchConversations(query: $query, corpusId: $corpusId, topK: $topK) {
                    id
                    title
                    description
                    conversationType
                }
            }
        """

        corpus_global_id = to_global_id("CorpusType", self.corpus.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test search query",
                "corpusId": corpus_global_id,
                "topK": 5,
            },
        )

        # Should not have errors
        self.assertIsNone(result.get("errors"))

        # Should return data
        self.assertIsNotNone(result.get("data"))
        conversations = result["data"]["searchConversations"]

        # Should be a list
        self.assertIsInstance(conversations, list)

    def test_search_messages_query(self):
        """Test the searchMessages GraphQL query."""
        query = """
            query SearchMessages($query: String!, $conversationId: ID, $topK: Int) {
                searchMessages(query: $query, conversationId: $conversationId, topK: $topK) {
                    id
                    content
                    msgType
                }
            }
        """

        conversation_global_id = to_global_id("ConversationType", self.conversation.id)

        result = self.client.execute(
            query,
            variables={
                "query": "test message query",
                "conversationId": conversation_global_id,
                "topK": 5,
            },
        )

        # Should not have errors
        self.assertIsNone(result.get("errors"))

        # Should return data
        self.assertIsNotNone(result.get("data"))
        messages = result["data"]["searchMessages"]

        # Should be a list
        self.assertIsInstance(messages, list)

    def test_search_requires_authentication(self):
        """Test that search queries require authentication."""
        # Create client without authenticated user
        anonymous_client = Client(schema, context_value=TestContext(None))

        query = """
            query SearchConversations($query: String!) {
                searchConversations(query: $query) {
                    id
                    title
                }
            }
        """

        result = anonymous_client.execute(
            query,
            variables={"query": "test"},
        )

        # Should have errors (not authenticated)
        self.assertIsNotNone(result.get("errors"))
