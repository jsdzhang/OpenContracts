"""
ThreadUpdatesConsumer

WebSocket consumer for real-time thread/conversation updates.
Clients subscribe to this to receive:
- Agent response streaming tokens
- Tool call notifications
- Response completion events
- Error notifications

This consumer is read-only - it only broadcasts updates from Celery tasks.
The actual agent responses are generated by the generate_agent_response task.

Query Parameters:
    conversation_id: Required GraphQL ID for the conversation to watch
"""

from __future__ import annotations

import json
import logging
import urllib.parse
import uuid

from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from graphql_relay import from_global_id

from opencontractserver.conversations.models import Conversation

logger = logging.getLogger(__name__)


def get_thread_channel_group(conversation_id: int) -> str:
    """Get the channel group name for a conversation/thread."""
    return f"thread_{conversation_id}"


class ThreadUpdatesConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for subscribing to thread updates.

    Clients connect with a conversation_id and receive real-time updates
    about agent responses being generated in that thread.

    This consumer does NOT handle sending messages - that's done via GraphQL.
    It only receives and broadcasts updates from Celery tasks.
    """

    conversation: Conversation | None = None
    conversation_id: int | None = None
    session_id: str | None = None
    user_id: int | None = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.consumer_id = uuid.uuid4()
        logger.debug(f"[ThreadUpdates {self.consumer_id}] __init__ called.")

    # -------------------------------------------------------------------------
    #  WebSocket lifecycle
    # -------------------------------------------------------------------------

    async def connect(self) -> None:
        """
        Authenticate, extract conversation_id, validate access, and subscribe.
        """
        self.session_id = str(uuid.uuid4())
        logger.debug(
            f"[ThreadUpdates {self.consumer_id} | Session {self.session_id}] "
            f"connect() called. Path: {self.scope['path']}"
        )

        # Extract user from scope (set by auth middleware)
        user = self.scope.get("user")
        if not user or not user.is_authenticated:
            logger.warning(
                f"[ThreadUpdates {self.consumer_id}] Unauthenticated connection rejected"
            )
            await self.close(code=4001)
            return

        self.user_id = user.pk

        # Parse query parameters
        query_string = self.scope.get("query_string", b"").decode("utf-8")
        params = dict(urllib.parse.parse_qsl(query_string))

        raw_conversation_id = params.get("conversation_id")
        if not raw_conversation_id:
            logger.warning(
                f"[ThreadUpdates {self.consumer_id}] No conversation_id provided"
            )
            await self.close(code=4002)
            return

        # Decode GraphQL ID
        try:
            _, pk_str = from_global_id(raw_conversation_id)
            self.conversation_id = int(pk_str)
        except Exception:
            try:
                self.conversation_id = int(raw_conversation_id)
            except ValueError:
                logger.warning(
                    f"[ThreadUpdates {self.consumer_id}] Invalid conversation_id: {raw_conversation_id}"
                )
                await self.close(code=4002)
                return

        # Validate access to conversation
        has_access = await self._check_conversation_access(user)
        if not has_access:
            logger.warning(
                f"[ThreadUpdates {self.consumer_id}] Access denied for conversation {self.conversation_id}"
            )
            await self.close(code=4003)
            return

        # Subscribe to thread channel group
        self.room_group_name = get_thread_channel_group(self.conversation_id)
        await self.channel_layer.group_add(self.room_group_name, self.channel_name)

        await self.accept()
        logger.info(
            f"[ThreadUpdates {self.consumer_id}] Subscribed to {self.room_group_name}"
        )

        # Send connection confirmation
        await self.send(
            text_data=json.dumps(
                {
                    "type": "CONNECTED",
                    "conversation_id": str(self.conversation_id),
                    "session_id": self.session_id,
                }
            )
        )

    async def disconnect(self, close_code: int) -> None:
        """Leave the thread channel group on disconnect."""
        if hasattr(self, "room_group_name") and self.room_group_name:
            await self.channel_layer.group_discard(
                self.room_group_name, self.channel_name
            )
            logger.info(
                f"[ThreadUpdates {self.consumer_id}] Disconnected from {self.room_group_name}"
            )

    async def receive(self, text_data: str) -> None:
        """
        Handle incoming messages from client.

        This consumer is primarily for receiving broadcasts, but we handle
        a few client-initiated message types for connection management.
        """
        try:
            data = json.loads(text_data)
            msg_type = data.get("type", "")

            if msg_type == "ping":
                await self.send(text_data=json.dumps({"type": "pong"}))

            elif msg_type == "heartbeat":
                await self.send(
                    text_data=json.dumps(
                        {
                            "type": "heartbeat_ack",
                            "session_id": self.session_id,
                        }
                    )
                )

            else:
                logger.debug(
                    f"[ThreadUpdates {self.consumer_id}] Unknown message type: {msg_type}"
                )

        except json.JSONDecodeError:
            logger.warning(f"[ThreadUpdates {self.consumer_id}] Invalid JSON received")

    # -------------------------------------------------------------------------
    #  Channel layer message handlers (from Celery tasks)
    # -------------------------------------------------------------------------

    async def agent_stream_start(self, event: dict) -> None:
        """Handle agent starting to generate a response."""
        await self.send(
            text_data=json.dumps(
                {
                    "type": "AGENT_STREAM_START",
                    "message_id": event.get("message_id"),
                    "agent_id": event.get("agent_id"),
                    "agent_name": event.get("agent_name"),
                    "agent_slug": event.get("agent_slug"),
                }
            )
        )

    async def agent_stream_token(self, event: dict) -> None:
        """Handle streaming token from agent."""
        await self.send(
            text_data=json.dumps(
                {
                    "type": "AGENT_STREAM_TOKEN",
                    "message_id": event.get("message_id"),
                    "token": event.get("token"),
                }
            )
        )

    async def agent_tool_call(self, event: dict) -> None:
        """Handle agent calling a tool."""
        await self.send(
            text_data=json.dumps(
                {
                    "type": "AGENT_TOOL_CALL",
                    "message_id": event.get("message_id"),
                    "tool": event.get("tool"),
                    "args": event.get("args"),
                }
            )
        )

    async def agent_stream_complete(self, event: dict) -> None:
        """Handle agent completing response generation."""
        await self.send(
            text_data=json.dumps(
                {
                    "type": "AGENT_STREAM_COMPLETE",
                    "message_id": event.get("message_id"),
                    "content": event.get("content"),
                    "sources": event.get("sources", []),
                    "timeline": event.get("timeline", []),
                }
            )
        )

    async def agent_stream_error(self, event: dict) -> None:
        """Handle agent error during response generation."""
        await self.send(
            text_data=json.dumps(
                {
                    "type": "AGENT_STREAM_ERROR",
                    "message_id": event.get("message_id"),
                    "error": event.get("error"),
                }
            )
        )

    # -------------------------------------------------------------------------
    #  Helper methods
    # -------------------------------------------------------------------------

    @database_sync_to_async
    def _check_conversation_access(self, user) -> bool:
        """Check if user has access to the conversation."""
        try:
            conversation = Conversation.objects.get(pk=self.conversation_id)
            self.conversation = conversation

            # Check if user can participate in this conversation
            # Options: owner, corpus member, or public conversation
            if conversation.creator_id == user.pk:
                return True

            if user.is_superuser:
                return True

            # Check corpus access if conversation is corpus-scoped
            if conversation.chat_with_corpus:
                from opencontractserver.corpuses.models import Corpus

                try:
                    Corpus.objects.visible_to_user(user).get(
                        pk=conversation.chat_with_corpus_id
                    )
                    return True
                except Corpus.DoesNotExist:
                    return False

            # Check document access if conversation is document-scoped
            if conversation.chat_with_document:
                from opencontractserver.documents.models import Document

                try:
                    Document.objects.visible_to_user(user).get(
                        pk=conversation.chat_with_document_id
                    )
                    return True
                except Document.DoesNotExist:
                    return False

            return False

        except Conversation.DoesNotExist:
            return False
